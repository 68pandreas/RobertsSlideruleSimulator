<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.2/react-dom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.21.1/babel.min.js"></script>

<script type="text/babel">
var roundRect = function (ctx, left, top, right, bottom, radius) {
  var step = Math . PI * 0.5; ctx . moveTo (left + radius, top); ctx . lineTo (right - radius, top); ctx . arc (right - radius, top + radius, radius, -step, 0);
  ctx . lineTo (right, bottom - radius); ctx . arc (right - radius, bottom - radius, radius, 0, step); ctx . lineTo (left + radius, bottom);
  ctx . arc (left + radius, bottom - radius, radius, step, step + step); ctx . lineTo (left, top + radius); ctx . arc (left + radius, top + radius, radius, step + step, - step);
};

var addv = function (v1, v2) {return {x: v1 . x + v2 . x, y: v1 . y + v2 . y};};
var subv = function (v1, v2) {return {x: v1 . x - v2 . x, y: v1 . y - v2 . y};};
var scalv = function (vector, scale) {return {x: vector . x * scale, y: vector . y * scale};};

var tick = function (ctx, x, height) {ctx . beginPath (); ctx . moveTo (x, 0); ctx . lineTo (x, - height); ctx . stroke ();};
var stick = function (ctx, x, base, height) {ctx . beginPath (); ctx . moveTo (x, - base); ctx . lineTo (x, - height); ctx . stroke ();};
var mark = function (ctx, ind, x, height) {tick (ctx, x, height); if (height < 0) ctx . fillText (ind, x, - height - height - 3); else ctx . fillText (ind, x, - height - 2);};
var smark = function (ctx, ind, x, base, height) {
  stick (ctx, x, base, height);
  if (height < 0) ctx . fillText (ind, x, - height - height - 3);
  else ctx . fillText (ind, x, - height - 2);
};

var draw_XR = function (ctx, fn, length, from, to, limit, height, step, micro_from, micro_to) {
  var esc = true; var location;
  for (var ind = from; esc && ind < to; ind += step) {
    for (var sub = micro_from; esc && sub < micro_to; sub += micro_from) {
      location = fn (ind + sub);
      if (location > limit) esc = false;
      else tick (ctx, length * location, height);
    }
  }
};
var draw_05R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 1, 0.5, 1);};
var draw_02R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 1, 0.2, 1);};
var draw_01R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 0.5, 0.1, 0.5);};
var draw_005R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 0.1, 0.05, 0.1);};
var draw_002R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 0.1, 0.02, 0.1);};
var draw_001R = function (ctx, fn, length, from, to, limit, height) {draw_XR (ctx, fn, length, from, to, limit, height, 0.05, 0.01, 0.05);};
var draw_XL = function (ctx, fn, length, from, to, limit, height, step, micro_from, micro_to) {
  var esc = true; var location;
  for (var ind = to; esc && ind > from; ind -= step) {
    for (var sub = micro_from; esc & sub < micro_to; sub += micro_from) {
      location = fn (ind - sub);
      if (location < limit) esc = false;
      else tick (ctx, length * location, height);
    }
  }
};
var draw_05L = function (ctx, fn, length, from, to, limit, height) {draw_XL (ctx, fn, length, from, to, limit, height, 1, 0.5, 1);};
var draw_02L = function (ctx, fn, length, from, to, limit, height) {draw_XL (ctx, fn, length, from, to, limit, height, 1, 0.2, 1);};
var draw_01L = function (ctx, fn, length, from, to, limit, height) {draw_XL (ctx, fn, length, from, to, limit, height, 0.5, 0.1, 0.5);};
var draw_002L = function (ctx, fn, length, from, to, limit, height) {draw_XL (ctx, fn, length, from, to, limit, height, 0.1, 0.02, 0.1);};
var draw_001L = function (ctx, fn, length, from, to, limit, height) {draw_XL (ctx, fn, length, from, to, limit, height, 0.05, 0.01, 0.05);};
var draw_MR = function (ctx, fn, length, from, to, limit, height) {
  var esc = true; var location;
  for (var ind = from; esc && ind <= to; ind++) {
    location = fn (ind);
    if (location > limit) esc = false;
    else mark (ctx, ind, length * location, height);
  }
};
var draw_ML = function (ctx, fn, length, from, to, limit, height) {
  var esc = true; var location;
  for (var ind = to; esc && ind >= from; ind--) {
    location = fn (ind);
    if (location < limit) esc = false;
    else mark (ctx, ind, length * location, height);
  }
};

var spacer = function (height, options) {
  this . height = height;
  this . ruleHeight = function () {return this . height;};
  this . hitTest = function (y) {return false;};
  this . la = 'left'; this . ra = 'right'; this . ca = 'center';
  this . ls = 0.06; this . rs = 0.06; this . cs = 0.5;
  this . colour = 'black'; this . alt = 'red';
  this . left_extension = 0; this . right_extension = 0;
  this . highlight_left = 0; this . highlight_right = 0;
  this . draw = function (ctx, length) {};
  this . value = function (location) {return null;};
  this . location = function (value) {return NaN;};
  this . sub_draw = function (ctx, length) {
    if (this . highlight) {ctx . fillStyle = this . highlight; ctx . fillRect (length * - this . highlight_left, 0, length * (1 + this . highlight_left + this . highlight_right), this . height);}
    ctx . fillStyle = this . colour;
    ctx . strokeStyle = this . colour;
    ctx . font = (height * 0.5) + 'px arial';
    ctx . textAlign = 'center';
    ctx . save ();
    this . draw (ctx, length);
    ctx . restore ();
    if (this . font) ctx . font = this . font;
    var textBase = this . height * 0.75;
    if (this . baseline !== undefined) textBase = this . baseline;
    if (this . textBaseline !== undefined) ctx . textBaseline = this . textBaseline;
    if (this . left_description !== undefined) {ctx . textAlign = this . la; ctx . fillText (this . left_description, - length * this . ls, textBase);}
    if (this . right_description !== undefined) {ctx . textAlign = this . ra; ctx . fillText (this . right_description, length * (1 + this . rs), textBase);}
    if (this . centre_description !== undefined) {ctx . textAlign = this . ca; ctx . fillText (this . centre_description, length * this . cs, textBase);}
  };
  this . examine = function (position) {
    if (position . y < 0 || position . y > this . height) return null;
    var p = prompt ('Value for: ' + (this . left_description ? this . left_description : '') + ' ' + (this . right_description ? this . right_description : '') , '0.0000');
    if (p === null) return null;
    switch (p) {
      case 'pi': p = Math . PI; break;
      case 'pi1': p = Math . PI * 10; break;
      case 'e': p = Math . E; break;
      case 'e1': p = Math . E * 10; break;
      case 'c': p = Math . sqrt (4 / Math . PI); break;
      case 'c1': p = Math . sqrt (40 / Math . PI); break;
      default: p = Number (p); break;
    }
    p = this . location (p);
    if (isNaN (p)) return null;
    return p;
  };
  for (var key in options) this [key] = options [key];
};

var draw_log = function (ctx, length, height, scale) {
  mark (ctx, 1, length, height * 0.5);
  smark (ctx, '\u03c0', length * Math . log10 (Math . PI), height * 0.2, height * 0.5);
  smark (ctx, 'e', length * Math . log10 (Math . E), height * 0.2, height * 0.5);
  smark (ctx, 'c', length * Math . log10 (Math . sqrt (4 / Math . PI)), height * 0.2, height * 0.5);
  smark (ctx, 'c1', length * (0.5 + Math . log10 (Math . sqrt (4 / Math . PI))), height * 0.2, height * 0.5);
  draw_MR (ctx, Math . log10, length, 1, 9, 1, height * 0.5);
  draw_002R (ctx, Math . log10, length, 1, 2, 1, height * 0.2);
  draw_01R (ctx, Math . log10, length, 1, 10, 1, height * 0.3);
  draw_05R (ctx, Math . log10, length, 1, 10, 1, height * 0.4);
  ctx . translate (length, 0);
  ctx . strokeStyle = scale . alt; ctx . fillStyle = scale . alt;
  draw_002R (ctx, Math . log10, length, 1, 10, scale . right_extension, height * 0.2);
  draw_01R (ctx, Math . log10, length, 1, 10, scale . right_extension, height * 0.3);
  ctx . translate (- length - length, 0);
  draw_01L (ctx, Math . log10, length, 1, 10, 1 - scale . left_extension, height * 0.2);
  draw_05L (ctx, Math . log10, length, 1, 10, 1 - scale . left_extension, height * 0.3);
  draw_ML (ctx, Math . log10, length, 1, 9, 1 - scale . left_extension, height * 0.5);
};
var draw_one_log = function (ctx, length, height) {
  draw_MR (ctx, Math . log10, length, 1, 9, 1, height * 0.5);
  draw_05R (ctx, Math . log10, length, 1, 8, 1, height * 0.4);
  draw_02R (ctx, Math . log10, length, 8, 10, 1, height * 0.3);
  draw_01R (ctx, Math . log10, length, 1, 8, 1, height * 0.3);
  draw_002R (ctx, Math . log10, length, 1, 2, 1, height * 0.2);
};
var draw_log_log = function (ctx, length, height, scale) {
  mark (ctx, 1, length, height * 0.5); length *= 0.5;
  smark (ctx, '\u03c0', length * Math . log10 (Math . PI), height * 0.2, height * 0.5);
  smark (ctx, 'e', length * Math . log10 (Math . E), height * 0.2, height * 0.5);
  smark (ctx, '\u03c0', length * Math . log10 (Math . PI * 10), height * 0.2, height * 0.5);
  smark (ctx, 'e', length * Math . log10 (Math . E * 10), height * 0.2, height * 0.5);
  draw_one_log (ctx, length, height); ctx . translate (length, 0); draw_one_log (ctx, length, height);
  ctx . strokeStyle = scale . alt; ctx . fillStyle = scale . alt;
  ctx . translate (length, 0);
  draw_05R (ctx, Math . log10, length, 1, 9, scale . right_extension * 2, height * 0.4);
  draw_01R (ctx, Math . log10, length, 1, 8, scale . right_extension * 2, height * 0.3);
  draw_002R (ctx, Math . log10, length, 1, 2, scale . right_extension * 2, height * 0.2);
  ctx . translate (length * -3, 0);
  draw_ML (ctx, Math . log10, length, 1, 9, 1 - scale . left_extension * 2, height * 0.5);
  draw_05L (ctx, Math . log10, length, 1, 8, 1 - scale . left_extension * 2, height * 0.4);
  draw_02L (ctx, Math . log10, length, 8, 10, 1 - scale . left_extension * 2, height * 0.3);
  draw_01L (ctx, Math . log10, length, 1, 8, 1 - scale . left_extension * 2, height * 0.3);
};
var draw_log_log_log = function (ctx, length, height, scale) {
  mark (ctx, 1, length, height * 0.5); length /= 3;
  draw_one_log (ctx, length, height); ctx . translate (length, 0); draw_one_log (ctx, length, height); ctx . translate (length, 0); draw_one_log (ctx, length, height);
  ctx . strokeStyle = scale . alt; ctx . fillStyle = scale . alt;
  ctx . translate (length, 0);
  draw_05R (ctx, Math . log10, length, 1, 9, scale . right_extension * 2, height * 0.4);
  draw_01R (ctx, Math . log10, length, 1, 8, scale . right_extension * 2, height * 0.3);
  draw_002R (ctx, Math . log10, length, 1, 2, scale . right_extension * 2, height * 0.2);
  ctx . translate (length * -3, 0);
  draw_ML (ctx, Math . log10, length, 1, 9, 1 - scale . left_extension * 2, height * 0.5);
  draw_05L (ctx, Math . log10, length, 1, 8, 1 - scale . left_extension * 2, height * 0.4);
  draw_02L (ctx, Math . log10, length, 8, 10, 1 - scale . left_extension * 2, height * 0.3);
  draw_01L (ctx, Math . log10, length, 1, 8, 1 - scale . left_extension * 2, height * 0.3);
};
var fn_lin = function (value) {return value * 0.1;};
var draw_lin = function (ctx, length, height, scale) {
  draw_MR (ctx, fn_lin, length, 0, 10, 1, height * 0.5);
  draw_05R (ctx, fn_lin, length, 0, 10, 1, height * 0.4);
  draw_01R (ctx, fn_lin, length, 0, 10, 1, height * 0.3);
  draw_005R (ctx, fn_lin, length, 0, 10, 1, height * 0.2);
};

var scale_A = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location + location);};
  s . location = function (value) {return Math . log10 (value) * 0.5;};
  s . draw = function (ctx, length) {ctx . translate (0, s . height); draw_log_log (ctx, length, height, s);};
  return s;
};

var scale_B = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location + location);};
  s . location = function (value) {return Math . log10 (value) * 0.5;};
  s . draw = function (ctx, length) {draw_log_log (ctx, length, - s . height, s);};
  return s;
};

var scale_C = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location);};
  s . location = function (value) {return Math . log10 (value);};
  s . draw = function (ctx, length) {ctx . translate (0, s . height); draw_log (ctx, length, s . height, s);};
  return s;
};

var scale_D = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location);};
  s . location = function (value) {return Math . log10 (value);};
  s . draw = function (ctx, length) {draw_log (ctx, length, - s . height, s);};
  return s;
};

var scale_K = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location * 3);};
  s . location = function (value) {return Math . log10 (value) / 3;};
  s . draw = function (ctx, length) {ctx . translate (0, s . height); draw_log_log_log (ctx, length, s . height, s);};
  return s;
};

var scale_J = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return Math . pow (10, location * 3);};
  s . location = function (value) {return Math . log10 (value) / 3;};
  s . draw = function (ctx, length) {draw_log_log_log (ctx, length, - s . height, s);};
  return s;
};

var scale_L = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return location * 10;};
  s . draw = function (ctx, length) {ctx . translate (0, s . height); draw_lin (ctx, length, s . height, s);};
  return s;
};
var scale_M = function (height, options) {
  var s = new spacer (height, options);
  s . value = function (location) {return location * 10;};
  s . draw = function (ctx, length) {draw_lin (ctx, length, - s . height, s);};
  return s;
};

var Rule = function (length, options) {
  this . length = length;
  this . stator = 0;
  this . left_margin = 0.2; this . right_margin = 0.2;
  this . shift = 0; this . target = 0; this . animation_delta = 0.004;
  this . rule_motion = 0.1;
  this . scales = [];
  this . move = function (delta) {this . target += this . rule_motion * delta / this . length; this . shift = this . target;};
  this . ruleHeight = function () {var h = 0; for (var ind in this . scales) h += this . scales [ind] . height; return h;};
  this . hitTest = function (y) {return this . stator > 0 && y >= 0 && y <= this . ruleHeight ();};
  this . draw = function (ctx) {
    ctx . save ();
    ctx . fillStyle = 'white';
    ctx . lineWidth = 1;
    ctx . translate (this . length * (this . shift - this . left_margin), 0);
    ctx . beginPath (); roundRect (ctx, 0, 0, (1 + this . left_margin + this . right_margin) * this . length, this . ruleHeight (), 12); ctx . fill (); ctx . stroke ();
    ctx . fillStyle = 'black';
    ctx . translate (this . left_margin * this . length, 0);
    var scale;
    for (var ind in this . scales) {
      scale = this . scales [ind];
      ctx . save ();
      scale . sub_draw (ctx, this . length);
      ctx . restore ();
      ctx . translate (0, this . scales [ind] . height);
    }
    ctx . restore ();
    if (this . target < this . shift) {
      this . shift -= this . animation_delta;
      if (this . shift < this . target) this . shift = this . target;
    }
    if (this . target > this . shift) {
      this . shift += this . animation_delta;
      if (this . shift > this . target) this . shift = this . target;
    }
  };
  this . examine = function (position) {
    if (position . y < 0 || position . y > this . ruleHeight ()) return null;
    var value;
    for (var ind in this . scales) {
      value = this . scales [ind] . examine (position);
      if (value !== null) return value;
      position = subv (position, {x: 0, y: this . scales [ind] . height});
    }
    return null;
  };
  for (var key in options) this [key] = options [key];
};

var Cursor = function (shift, from, to, colour) {
  this . draw = function (ctx, length) {
    length *= shift;
    ctx . save ();
    ctx . strokeStyle = colour;
    ctx . beginPath (); ctx . moveTo (length, from); ctx . lineTo (length, to); ctx . stroke ();
    ctx . restore ();
  };
};

var Sliderule = function (length, options) {
  this . length = length;
  this . left_margin = 0.2; this . right_margin = 0.2;
  this . position = {x: 0, y: 0};
  this . rules = [];
  this . animation_delta = 0.004;
  this . cursor_position = 1; this . cursor_target = 0; this . cursor_colour = 'red'; this . cursor_motion = 0.1;
  this . cursors = [];
  this . cursor_left_extension = 0.1; this . cursor_right_extension = 0.1;
  this . cursor_markings = true;
  this . precision = 5;
  this . height = function () {var h = 0; for (var ind in this . rules) h += this . rules [ind] . ruleHeight (); return h;};
  this . moveCursor = function (delta) {this . cursor_target += this . cursor_motion * delta / this . length; this . cursor_position = this . cursor_target;};
  this . moveRule = function (delta, position) {
    if (position . y > this . height ()) return;
    var y = position . y;
    for (var ind in this . rules) {
      if (this . rules [ind] . hitTest (y)) {this . rules [ind] . move (delta . x); return this . rules [ind] . stator;}
      y -= this . rules [ind] . ruleHeight ();
    }
    this . moveCursor (delta . x);
    return 0;
  };
  this . draw = function (ctx) {
    ctx . save ();
    ctx . translate (this . length * this . left_margin, 0);
    var ind;
    for (ind in this . rules) {
      this . rules [ind] . draw (ctx);
      ctx . translate (0, this . rules [ind] . ruleHeight ());
    }
    ctx . restore ();
    ctx . translate (this . length * (this . left_margin + this . cursor_position), 0);
    ctx . strokeStyle = this . cursor_colour;
    ctx . beginPath (); roundRect (ctx, - this . length * this . cursor_left_extension, -4, this . length * this . cursor_right_extension, this . height () + 4, 4);
    ctx . fillStyle = '#0001';
    ctx . fill (); ctx . stroke ();
    ctx . beginPath ();
    ctx . moveTo (0, -4); ctx . lineTo (0, this . height () + 4);
    ctx . stroke ();
    for (ind in this . cursors) {this . cursors [ind] . draw (ctx, this . length);}
    var y = 0;
    ctx . textBaseline = 'middle';
    ctx . font = '12px arial';
    var h; var hh; var description; var measure;
    for (ind in this . rules) {
      for (var sub in this . rules [ind] . scales) {
        h = this . rules [ind] . scales [sub] . height;
        hh = h * 0.5;
        description = this . rules [ind] . scales [sub] . value (this . cursor_position - this . rules [ind] . shift);
        if (description !== null) {
          description = description . toFixed (this . precision);
          ctx . fillStyle = 'white';
          measure = ctx . measureText (description);
          ctx . fillRect (4, y + hh - 8, measure . width + 8, 14);
          ctx . fillStyle = 'black';
          ctx . fillText (description, 8, y + hh);
        }
        y += h;
      }
    }
    if (this . cursor_target < this . cursor_position) {
      this . cursor_position -= this . animation_delta;
      if (this . cursor_position < this . cursor_target) this . cursor_position = this . cursor_target;
    }
    if (this . cursor_target > this . cursor_position) {
      this . cursor_position += this . animation_delta;
      if (this . cursor_position > this . cursor_target) this . cursor_position = this . cursor_target;
    }
  };
  this . examine = function (position) {
    if (position . y < 0 || position . y > this .height ()) return false;
    position = subv (position, {x: this . length * this . left_margin, y: 0});
    var is_cursor = position . x / this . length - this . cursor_position;
    is_cursor = (is_cursor < this . cursor_right_extension && is_cursor > - this . cursor_left_extension);
    var value;
    var target;
    for (var ind in this . rules) {
      value = this . rules [ind] . examine (position);
      if (value !== null) {
        if (is_cursor || this . rules [ind] . stator < 1) {
          target = value + this . rules [ind] . shift;
          if (target < - this . left_margin) target = - this . left_margin;
          if (target > 1 + this . right_margin) target = 1 + this . right_margin;
          this . cursor_target = target;
        } else {
          target = - value + this . cursor_target;
          if (target < -1 - this . left_margin) target = -1 - this . left_margin;
          if (target > 1 + this . right_margin) target = 1 + this . right_margin;
          this . rules [ind] . target = target;
        }
        return true;
      }
      //if (value !== null) {this . cursor_target = position . x / this . length; return true;}
      position = subv (position, {x: 0, y: this . rules [ind] . ruleHeight ()});
    }
    return false;
  };
  for (var key in options) this [key] = options [key];
};

var Sliderules = function () {
  this . position = {x: 32.5, y: 32.5};
  this . sliderules = [];
  this . synchroniseRules = function () {
  };
  this . synchroniseCursors = function () {
  };
  this . draw = function (ctx) {
    ctx . translate (this . position . x, this . position . y);
    for (var ind in this . sliderules) {
      ctx . translate (this . sliderules [ind] . position . x, this . sliderules [ind] . position . y);
      ctx . save ();
      this . sliderules [ind] . draw (ctx);
      ctx . restore ();
      ctx . translate (0, this . sliderules [ind] . height ());
    }
  };
  this . move = function (delta, position) {
    position = subv (position, this . position);
    for (var ind in this . sliderules) {
      position = subv (position, this . sliderules [ind] . position);
      this . sliderules [ind] . moveRule (delta, position);
      position = subv (position, {x: 0, y: this . sliderules [ind] . height ()});
      if (position . y < 0) return;
    }
  };
  this . examine = function (position) {
    position = subv (position, this . position);
    for (var ind in this . sliderules) {
      position = subv (position, this . sliderules [ind] . position);
      if (this . sliderules [ind] . examine (position)) return;
      position = subv (position, {x: 0, y: this . sliderules [ind] . height ()});
    }
  };
};

var sliderules = new Sliderules ();

var sliderule = new Sliderule (1200);
sliderule . cursor_position = 0.1;
sliderules . sliderules . push (sliderule);
var r = new Rule (1200);
sliderule . rules . push (r);
r . scales . push (new spacer (4));
r . scales . push (new scale_L (24));
r . scales . push (new spacer (4));
r . scales . push (new scale_K (24, {left_description: 'X sonda\u03c0 \u03c9'}));
r . scales . push (new spacer (4));
r . scales . push (new scale_A (24));
r = new Rule (1200);
sliderule . rules . push (r);
r . stator = 1;
r . scales . push (new scale_B (24));
r . scales . push (new spacer (4));
r . scales . push (new scale_C (24));
r = new Rule (1200);
sliderule . rules . push (r);
r . scales . push (new scale_D (24));
r . scales . push (new spacer (4));

sliderule = new Sliderule (1200, {position: {x: -6, y: 22}});
sliderules . sliderules . push (sliderule);
sliderule . cursor_position = 0.4;
sliderule . cursors . push (new Cursor (-0.06, 40, 120, 'blue'));
r = new Rule (1200);
sliderule . rules . push (r);
r . scales . push (new scale_L (24));
r . scales . push (new spacer (24));
r . scales . push (new scale_C (48, {left_extension: 0.1, right_extension: 0.1}));
r . scales . push (new scale_C (48, {highlight: 'green', highlight_left: 0.05, highlight_right: 0.05}));
r . scales . push (new scale_D (48));
r . scales . push (new scale_A (48, {left_description: 'X\u00B2', ls: 0.09, left_extension: 0.1, right_extension: 0.1}));
r . scales . push (new spacer (24, {left_description: 'sputnik', centre_description: 'SKALA', baseline: 24, font: '24px arial', textBaseline: 'bottom'}));
sliderule . rules . push (new spacer (4));
r = new Rule (1200, {left_margin: 0.1});
sliderule . rules . push (r);
r . scales . push (new scale_B (48, {right_description: 'X\u00B3'}));
r . scales . push (new scale_D (48));
r . scales . push (new scale_M (28));
r . stator = 1;

var App = React . createClass ({
  dragging: false,
  mousePosition: {x: 0, y: 0},
  onContext: function (event) {event . preventDefault ();},
  onMouseDown: function (event) {
    var position = {x: event . clientX, y: event . clientY};
    if (event . button === 2) {
      sliderules . examine (addv (position, {x: 0.5, y: 0}));
      return;
    }
    this . dragging = true;
    this . mousePosition = position;
  },
  onMouseMove: function (event) {
    if (! this . dragging) return;
    var position = {x: event . clientX, y: event . clientY};
    var delta = subv (position, this . mousePosition);
    //for (var ind in sliderules) sliderules [ind] . moveCursor (delta . x);
    sliderules . move (delta, position);
    this . mousePosition = position;
  },
  onMouseUp: function (event) {this . dragging = false; this . setState ({});},
  draw: function () {
    var width = window . innerWidth; var height = window . innerHeight;
    this . setState ({width: width, height: height});
    var ctx = this . refs . sliderule . getContext ('2d');
    ctx . setTransform (1, 0, 0, 1, 0, 0);
    ctx . fillStyle = '#99F';
    ctx . fillRect (0, 0, width, height);
    sliderules . draw (ctx);
  },
  componentDidMount: function () {setInterval (this . draw, 20);},
  getInitialState: function () {return {width: 200, height: 100, dragging: false};},
  render: function () {
    return (
      <div style = {{align: 'center'}}>
        <canvas ref = 'sliderule' width = {this . state . width} height = {this . state . height} style = {{display: 'block'}}
          onMouseDown = {this . onMouseDown}
          onMouseMove = {this . onMouseMove}
          onMouseUp = {this . onMouseUp}
          onMouseLeave = {this . onMouseUp}
          onContextMenu = {this . onContext}
        />
      </div>
    );
  }
});

class Greeting extends React.Component {
    render() {
        return (<p>Hello world</p>);
    }
}

ReactDOM.render(
    <App />,
    document.getElementById('root')
);
</script>
<div id="root"></div>

