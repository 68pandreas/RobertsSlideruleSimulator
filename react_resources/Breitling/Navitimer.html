<meta charset="UTF-8"/>

<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2021 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>


<header>
</header>

<body style="margin: 0px;">
<canvas id="Navitimer" width="1200" height="600"
	onmousedown="javascript: MouseDown (event);" onmouseup="javascript: MouseUp (event);"
	onmousemove="javascript: MouseMove (event);" onmouseleave="javascript: MouseUp (event);"
	oncontextmenu="javascript: event . preventDefault ();"
/>

<script type="text/javascript">

var Makers = {
	Breitling: {
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		StatorTop: 0.37,
		StatorBottom: 0.32,
		MinuteConversionLine: 0.31,
		Converters: 0.28,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		HoursSize: 0.06,
		HoursRadius: 0.215,
		TotalizerRadius: 0.172,
		TotalizerBezel: 0.09,
		TotalizerStator: 0.075,
		TotalizerR1: 0.086,
		TotalizerR2: 0.079,
		TotalizerR3: 0.075,
		TotalizerArrow1: 0.006,
		TotalizerArrow2: 0.004,
		TotalizerArrow3: 0.006,
		TotalizerArrow4: 0.01,
		TotalizerArrow5: 0.02,
		TotalizerArrow6: 0.035,
		TotalizerArrow7: 0.06,
		TotalizerNumbers: 0.05,
		TotalizerNumbersH: 0.056
	}
};

var Maker = 'Breitling';

var Status = {
	Monitor: true,
	Adjustment: 0,
};

var Chronograph = {
	From: null,
	To: null
};

Date . prototype . isDST = function () {
	var jan = new Date (this . getFullYear (), 0, 1);
	var jul = new Date (this . getFullYear (), 6, 1);
	var delta = Math . max (jan . getTimezoneOffset (), jul . getTimezoneOffset ());
	return this . getTimezoneOffset () < delta;
}

var AutoAdjust = function () {
	var DateNumber = Date . now ();
	var date = new Date (DateNumber);
	if (date . isDST ()) date = new Date (DateNumber - 3600000);
	var Day = (Math . floor (DateNumber / 86400000) % 31) + 1;
	Status . Adjustment = 86400000 * (date . getDate () - Day);
};

var BreitlingLogo = new Image (); BreitlingLogo . src = 'BreitlingWhiteScaled.png';

var canvas = document . getElementById ('Navitimer');
var ctx = canvas . getContext ('2d');
var pi2 = Math . PI + Math . PI;

var degree = 0;
var BezelTarget = 0;
var Cursor = 0;
var CursorTarget = 0;
var CursorVisible = false;

var SetBezelTarget = function (target) {
	while (target < 0) target += 1; while (target > 1) target -= 1;
	clearInterval (Interval);
	BezelTarget = target;
	if (BezelTarget > degree) {if (BezelTarget - degree > 0.5) BezelTarget -= 1;}
	else {if (degree - BezelTarget > 0.5) BezelTarget += 1;}
	Interval = setInterval (repaint, 25);
};

var SetCursorTarget = function (target) {
	while (target < 0) target += 1; while (target > 1) target -= 1;
	clearInterval (Interval);
	CursorTarget = target;
	if (CursorTarget > Cursor) {if (CursorTarget - Cursor > 0.5) CursorTarget -= 1;}
	else {if (Cursor - CursorTarget > 0.5) CursorTarget += 1;}
	Interval = setInterval (repaint, 25);
};

var point = null;
var point_length = 0;
var point_angle = 0;
var point_cursor_proximity = 0;
var atan = null;
var size = 0;

var PushpieceA = false;
var PushpieceB = false;

var PushA = function () {
	PushpieceA = true;
	if (Chronograph . From === null) {Chronograph . From = Date . now (); repaint (); return;}
	if (Chronograph . To === null) Chronograph . To = Date . now ();
	else {var now = Date . now (); var delta = now - Chronograph . To; Chronograph . From += delta; Chronograph . To = null;}
	repaint ();
};

var PushB = function () {
	PushpieceB = Date . now ();
	if (Chronograph . From !== null && Chronograph . To === null) Chronograph . From = Date . now ();
	else Chronograph . From = Chronograph . To = null;
	repaint ();
};

var PushC = function (angle) {
	console . log (angle);
};

var MousePoint = function (e) {
	var rect = canvas . getBoundingClientRect ();
	return {x: e . clientX - rect . left - canvas . width / 2, y: e . clientY - rect . top - canvas . height / 2};
};

var MouseDown = function (e) {
	point = MousePoint (e);
	point_length = Math . sqrt (point . x * point . x + point . y * point . y);
	atan = Math . atan2 (point . y, point . x);
	point_angle = atan / pi2 + 0.25;
	while (point_angle < 0) point_angle += 1; while (point_angle > 1) point_angle -= 1;
	point_cursor_proximity = Math . abs (point_angle - Cursor);
	var m = Makers [Maker];
	if (e . button != 0) {
		if (point_length < m . BezelRim * size && point_length > m . StatorBottom * size) {
			var command = prompt ();
			if (command !== null) {
				command = command . toLowerCase ();
				switch (command) {
				case 'pi': command = Math . PI; break;
				case 'e': command = Math . E; break;
				default: command = Number (command); break;
				}
				if (isFinite (command)) {
					command *= 10 / 6;
					while (command >= 10) command /= 10; while (command < 1) command *= 10;
					if (point_length < m . StatorTop * size) SetCursorTarget (Math . log10 (command));
					else {
						if (point_cursor_proximity < 0.02 || point_cursor_proximity > 0.98) SetCursorTarget (Math . log10 (command) + degree);
						else SetBezelTarget (1 - Math . log10 (command) + Cursor);
					}
				}
			}
		}
		point = null;
	}
	if (point_length > m . BezelRadius * size && point_length < size * 0.53) {
		var angle = 1 / 6;
		if (Math . abs (point_angle - angle) < 0.012) PushA ();
		if (Math . abs (point_angle - angle - angle) < 0.012) PushB ();
		if (Math . abs (point_angle - 0.25) < 0.025) PushC (point_angle);
	}
};

var MouseUp = function (e) {
	point = null; point_length = 0;
	if (PushpieceB) {
		var delay = Math . floor ((Date . now () - PushpieceB) / 1000);
		if (delay >= 4) AutoAdjust ();
	}
	if (PushpieceA || PushpieceB) {
		PushpieceA = PushpieceB = false;
		repaint ();
	}
};

var MouseMove = function (e) {
	var p = MousePoint (e);
	var length = Math . sqrt (p . x * p . x + p . y * p . y);
	var m = Makers [Maker];
	CursorVisible = (point && point_length < m . BezelRim * size && point_length > m . StatorBottom * size)
		|| (length < m . BezelRim * size && length > m . StatorBottom * size);
	if (! point) return;
	var a = Math . atan2 (p . y, p . x);
	if (point_length < m . BezelRim * size && point_length > m . StatorBottom * size) {
		if (point_length > m . StatorTop * size && point_cursor_proximity > 0.02 && point_cursor_proximity < 0.98) degree += (a - atan) / pi2;
		else if (point_cursor_proximity < 0.02 || point_cursor_proximity > 0.98) Cursor += (a - atan) / pi2;
		while (degree < 0) degree += 1; while (degree > 1) degree -= 1; BezelTarget = degree;
		while (Cursor < 0) Cursor += 1; while (Cursor > 1) Cursor -= 1; CursorTarget = Cursor;
	}
	point = p; atan = a;
	repaint ();
};

var mark = function (position, r1, r2) {
	var angle = Math . log10 (position) * pi2;
	var sin = Math . sin (angle); var cos = - Math . cos (angle);
	ctx . moveTo (r1 * sin, r1 * cos); ctx . lineTo (r2 * sin, r2 * cos);
};

var lmark = function (position, r1, r2) {
	var angle = position * pi2;
	var sin = Math . sin (angle); var cos = - Math . cos (angle);
	ctx . moveTo (r1 * sin, r1 * cos); ctx . lineTo (r2 * sin, r2 * cos);
};

AutoAdjust ();

var repaint = function () {
	//==== SIMULATION ====
	var CurrentDateNumber = Date . now ();
	var DateNumber = CurrentDateNumber + Status . Adjustment;
	var AllDays = Math . floor (DateNumber / 86400000);
	var Day = (AllDays % 31) + 1;
	var date = new Date (DateNumber);
	if (date . isDST ()) date = new Date (DateNumber - 3600000);
	if (BezelTarget != degree) {
		if (Math . abs (BezelTarget - degree) < 0.003125) {
			while (BezelTarget < 0) BezelTarget += 1; while (BezelTarget > 1) BezelTarget -= 1;
			degree = BezelTarget; clearInterval (Interval); Interval = setInterval (repaint, 250);
		} else {if (degree < BezelTarget) degree += 0.003125; else degree -= 0.003125;}
	}
	if (CursorTarget != Cursor) {
		if (Math . abs (CursorTarget - Cursor) < 0.003125) {
			while (CursorTarget < 0) CursorTarget += 1; while (CursorTarget > 1) CursorTarget -= 1;
			Cursor = CursorTarget; clearInterval (Interval); Interval = setInterval (repaint, 250);
		} else {if (Cursor < CursorTarget) Cursor += 0.003125; else Cursor -= 0.003125;}
	}
	//====================
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	size = canvas . height;
	var maker = Makers [Maker];
	var BezelRadius = - maker . BezelRadius * size;
	var BezelDent = BezelRadius / -20;
	var BezelRim = maker . BezelRim * size;
	var StatorTop = maker . StatorTop * size;
	var StatorBottom = - maker . StatorBottom * size;
	var r1 = StatorTop + 1; var r2 = StatorTop * 1.04; var r3 = StatorTop * 1.05; var r4 = StatorTop * 1.06;
	var rm1 = StatorTop; var rm2 = StatorTop * 0.96; var rm3 = StatorTop * 0.95; var rm4 = StatorTop * 0.94;
	var MinuteConversionLine = maker . MinuteConversionLine * size;
	var Converters = - maker . Converters * size;
	var NumberSize1 = maker . NumberSize1 * size;
	var NumberSize2 = maker . NumberSize2 * size;
	var BezelNumber = - maker . BezelNumbers * size;
	var BezelLeft = Math . PI / 2 - 1;
	var BezelRight = Math . PI / 2 + 1;
	var HoursSize = maker . HoursSize * size;
	var HoursRadius = maker . HoursRadius * size;
	//==== STATUS ===========
	var now = Date . now ();
	if (Status . Monitor) {
		ctx . fillText (`Current Date: ${new Date (now)}`, 10, 10);
		ctx . fillText (`Watch Date:   ${date . toString ()}`, 10, 20);
		ctx . fillText (`Current Milliseconds: ${now}`, 10, 30);
		ctx . fillText (`Watch Milliseconds:   ${DateNumber}`, 10, 40);
		ctx . fillText (`Total Days: ${AllDays}`, 10, 50);
		ctx . fillText (`Days mod 31: ${Day}`, 10, 60);
		ctx . fillText (`Chronograph: ${Chronograph . From === null ? '' :
			Chronograph . To === null ? Math . floor ((now - Chronograph . From) / 3600000) + ':' + Math . floor (((now - Chronograph . From) / 60000) % 60) + ':' + (((now - Chronograph . From) / 1000) % 60) . toFixed (2)
			: Math . floor ((Chronograph . To - Chronograph . From) / 3600000) + ':' + Math . floor (((Chronograph . To - Chronograph . From) / 60000) % 60)+ ':' + (((Chronograph . To - Chronograph . From) / 1000) % 60) . toFixed (2)}`,
			10, 80);
		ctx . fillText (`Adjustment [${Status . Adjustment}] => ${Math . floor (Status . Adjustment / 86400000)} days ${Math . floor (Status . Adjustment / 3600000) % 24} hours ${Math . floor (Status . Adjustment / 60000) % 60} minutes ${(Status . Adjustment % 1000) .toFixed (3)} seconds`, 10, 70);
		//ctx . fillText (`Point angle: ${point_angle}`, 10, 60);
		//ctx . fillText (`Cursor angle: ${Cursor}`, 10, 70);
		//ctx . fillText (`Cursor proximity: ${point_cursor_proximity}`, 10, 80);
	}
	//=======================
	ctx . save ();
	ctx . textBaseline = 'alphabetic';
	ctx . textAlign = 'center';
	ctx . font = `${NumberSize1}px arial`;
	ctx . translate (canvas . width * 0.5, canvas . height * 0.5);
	//==== PUSHPIECES ======================
	ctx . save ();
		var bw1 = size * 0.07; var bw2 = size * 0.075; var bw3 = size * 0.075; var bw4 = size * 0.04;
		var rw1 = size * 0.5; var rw2 = size * 0.45; var rw3 = size * 0.5; var rw4 = size * 0.51;
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		ctx . fillStyle = 'silver'; ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fillStyle = 'silver'; ctx . fill ();
		ctx . moveTo (rw3, - bw2); ctx . lineTo (rw3, bw2);
		ctx . moveTo (rw3, 0); ctx . lineTo (rw2, 0);
		ctx . moveTo (rw3, size * 0.02); ctx . lineTo (rw2, size * 0.02);
		ctx . moveTo (rw3, size * -0.02); ctx . lineTo (rw2, size * -0.02);
		ctx . moveTo (rw3, size * 0.038); ctx . lineTo (rw2, size * 0.038);
		ctx . moveTo (rw3, size * -0.038); ctx . lineTo (rw2, size * -0.038);
		ctx . moveTo (rw3, size * 0.054); ctx . lineTo (rw2, size * 0.054);
		ctx . moveTo (rw3, size * -0.054); ctx . lineTo (rw2, size * -0.054);
		ctx . moveTo (rw3, size * 0.068); ctx . lineTo (rw2, size * 0.068);
		ctx . moveTo (rw3, size * -0.068); ctx . lineTo (rw2, size * -0.068);
		ctx . lineWidth = 3; ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . rotate (pi2 / 12);
	//==============================
		var bw1 = size * 0.03; var bw2 = size * 0.035; var bw3 = size * 0.037; var bw4 = size * 0.02;
		var rw1 = size * 0.5; var rw2 = size * 0.475; var rw3 = size * 0.52; var rw4 = size * 0.53;
		if (PushpieceB) {var pub = size * 0.005; rw2 -= pub; rw3 -= pub; rw4 -= pub;}
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		ctx . fillStyle = 'silver'; ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fillStyle = 'navy'; ctx . fill (); ctx . stroke ();
	ctx . rotate (pi2 / -6);
	//==============================
		var bw1 = size * 0.03; var bw2 = size * 0.035; var bw3 = size * 0.037; var bw4 = size * 0.02;
		var rw1 = size * 0.5; var rw2 = size * 0.475; var rw3 = size * 0.52; var rw4 = size * 0.53;
		if (PushpieceA) {var pub = size * 0.005; rw2 -= pub; rw3 -= pub; rw4 -= pub;}
		ctx . beginPath ();
		ctx . moveTo (BezelRim, - bw1); ctx . lineTo (rw1, - bw1); ctx . lineTo (rw1, bw1); ctx . lineTo (BezelRim, bw1);
		ctx . lineWidth = 2;
		ctx . fillStyle = 'silver'; ctx . fill (); ctx . stroke ();
		ctx . beginPath ();
		ctx . moveTo (rw2, - bw2); ctx . lineTo (rw3, - bw3); ctx . bezierCurveTo (rw4, -bw4, rw4, bw4, rw3, bw3); ctx . lineTo (rw2, bw2); ctx . closePath ();
		ctx . fillStyle = 'navy'; ctx . fill (); ctx . stroke ();
	ctx . restore ();
	//==== BEZEL RIM ======================
	ctx . save ();
	ctx . rotate (degree * pi2);
	ctx . beginPath ();
	for (var ind = 0; ind < 60; ind ++) {
		ctx . arc (0, BezelRadius, BezelDent, BezelRight, BezelLeft, true);
		ctx . rotate (Math . PI / 30);
	}
	ctx . closePath ();
	ctx . moveTo (StatorTop, 0);
	ctx . arc (0, 0, StatorTop, 0, Math . PI * 2, true);
	ctx . stroke (); ctx . fillStyle = 'black'; ctx . fill ();
	ctx . strokeStyle = 'red';
	ctx . beginPath (); ctx . arc (0, 0, BezelRim, 0, Math . PI * 2); ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, BezelRim + 2, 0, Math . PI * 2); ctx . stroke ();
	//ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . stroke ();
	ctx . restore ();
	//==== BEZEL ======================
	ctx . save();
	var shift = Math . log10 (6);
	var position = shift;
	ctx . rotate (- pi2 * (position - degree));
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, r1, r3);
		mark (ind + 0.04, r1, r3);
		mark (ind + 0.06, r1, r3);
		mark (ind + 0.08, r1, r3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, r1, r2);
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.15, r1, r2);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.25, r1, r2);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.35, r1, r2);
		mark (ind + 0.4, r1, r3);
		mark (ind + 0.45, r1, r2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.4, r1, r3);
	}
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, r1, r4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, r1, r4);
	for (var ind = 6.5; ind < 12; ind += 0.5) if (ind !== 10) mark (ind, r1, r4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . fillStyle = 'red'; ctx . fillText ('10', 0, BezelNumber); ctx . fillStyle = 'white';
	var next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, BezelNumber); position = next;
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, BezelNumber); position = next;
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, BezelNumber); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, BezelNumber); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, BezelNumber); position = next;
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, BezelNumber); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, BezelNumber); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, BezelNumber); position = next;
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, BezelNumber); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, BezelNumber); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, BezelNumber); position = next;
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, BezelNumber); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, BezelNumber); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, BezelNumber); position = next;
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, BezelNumber); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, BezelNumber); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, BezelNumber); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, BezelNumber); position = next;
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, BezelNumber); position = next;
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, BezelNumber); position = next;
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, BezelNumber); position = next;
	next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('60', 0, BezelNumber); position = next;
	next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('65', 0, BezelNumber); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('70', 0, BezelNumber); position = next;
	next = Math . log10 (7.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('75', 0, BezelNumber); position = next;
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('80', 0, BezelNumber); position = next;
	next = Math . log10 (8.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('85', 0, BezelNumber); position = next;
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('90', 0, BezelNumber); position = next;
	next = Math . log10 (9.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('95', 0, BezelNumber); position = next;
	ctx . restore ();
	//==== BEZEL RED ARROWS ===================
	var t2 = StatorTop * -1.06; var t3 = StatorTop * -1.1;
	var s6 = size * 0.006;
	ctx . save ();
	ctx . rotate (degree * pi2);
	ctx . beginPath ();
	ctx . moveTo (0, - StatorTop - 1); ctx . lineTo (size * 0.006, BezelNumber * 0.99); ctx . lineTo (size * -0.006, BezelNumber * 0.99); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill ();
	ctx . rotate (- pi2 * shift);
	ctx . moveTo (0, - StatorTop - 1); ctx . lineTo (size * 0.006, BezelNumber * 0.99); ctx . lineTo (size * -0.006, BezelNumber * 0.99); ctx . closePath ();
	ctx . fill ();
	ctx . rotate (pi2 * Math . log10 (3.6));
	ctx . moveTo (0, t2); ctx . lineTo (size * 0.006, t3); ctx . lineTo (size * -0.006, t3); ctx . closePath ();
	ctx . fill ();
	ctx . restore ();
	//==== STATOR ======================
	ctx . save ();
	ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . fillStyle = 'black'; ctx . fill ();
	ctx . rotate (- pi2 * shift);
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, rm1, rm3);
		mark (ind + 0.04, rm1, rm3);
		mark (ind + 0.06, rm1, rm3);
		mark (ind + 0.08, rm1, rm3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, rm1, rm2);
		mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.15, rm1, rm2);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.25, rm1, rm2);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.35, rm1, rm2);
		mark (ind + 0.4, rm1, rm3);
		mark (ind + 0.45, rm1, rm2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		if (ind !== 6) mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.4, rm1, rm3);
	}
	mark (6, rm1, rm3);
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, rm1, rm4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, rm1, rm4);
	for (var ind = 6.5; ind < 12; ind += 0.5) if (ind !== 10) mark (ind, rm1, rm4);
	// mark (1.05, r1, r4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . font = `${NumberSize2}px arial`;
	ctx . fillStyle = 'red'; ctx . fillText ('10', 0, StatorBottom); ctx . fillStyle = 'white'; ctx . fillText ('1:40', 0, Converters);
	next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, StatorBottom); ctx . fillText ('1:50', 0, Converters); position = next;
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, StatorBottom); ctx . fillText ('2:00', 0, Converters); position = next;
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, StatorBottom); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, StatorBottom); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, StatorBottom); ctx . fillText ('2:30', 0, Converters); position = next;
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, StatorBottom); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, StatorBottom); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, StatorBottom); ctx . fillText ('3:00', 0, Converters); position = next;
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, StatorBottom); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, StatorBottom); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, StatorBottom); ctx . fillText ('3:30', 0, Converters); position = next;
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, StatorBottom); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, StatorBottom); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, StatorBottom); ctx . fillText ('4:00', 0, Converters); position = next;
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, StatorBottom); position = next;
	next = Math . log10 (2.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('4:30', 0, Converters); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, StatorBottom); ctx . fillText ('5:00', 0, Converters); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, StatorBottom); position = next;
	next = Math . log10 (3.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('6:00', 0, Converters); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, StatorBottom); position = next;
	next = Math . log10 (4.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('7:00', 0, Converters); position = next;
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, StatorBottom); position = next;
	next = Math . log10 (4.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('8:00', 0, Converters); position = next;
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, StatorBottom); position = next;
	next = Math . log10 (5.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('9:00', 0, Converters); position = next;
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, StatorBottom); position = next;
	//next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('60', 0, StatorBottom); position = next;
	//next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('65', 0, StatorBottom); position = next;
	next = Math . log10 (6.2); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('KM', 0, StatorBottom); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('7', 0, StatorBottom); ctx . fillText ('1:10', 0, Converters); position = next;
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('8', 0, StatorBottom); ctx . fillText ('1:20', 0, Converters); position = next;
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('9', 0, StatorBottom); ctx . fillText ('1:30', 0, Converters); position = next;
	ctx . restore ();
	//==== CONVERTERS ======================
	ctx . save ();
	ctx . fillStyle = 'white';
	ctx . beginPath ();
	ctx . moveTo (0, - StatorTop);
	r1 = size * 0.025; r2 = Converters * 0.88;
	ctx . bezierCurveTo (0, Converters * 0.5 - StatorTop * 0.5, r1 * 0.5, Converters, r1, Converters);
	ctx . lineTo (- r1, Converters);
	ctx . bezierCurveTo (r1 * -0.5, Converters, 0, Converters * 0.5 - StatorTop * 0.5, 0, - StatorTop);
	ctx . fill ();
	ctx . fillText ('MPH', 0, Converters * 0.895);
	ctx . beginPath ();
	r1 = size * 0.042;
	ctx . moveTo (- r1, Converters);
	ctx . lineTo (- r1, r2); ctx . lineTo (r1, r2); ctx . lineTo (r1, Converters);
	ctx . strokeStyle = 'white'; ctx . lineWidth = 3; ctx . stroke ();
	ctx . rotate (pi2 * - shift);
	ctx . strokeStyle = 'white';
	ctx . lineWidth = 1;
	ctx . beginPath (); ctx . arc (0, 0, MinuteConversionLine, 0, pi2); ctx . stroke ();
	ctx . beginPath ();
	r1 = MinuteConversionLine; r2 = MinuteConversionLine * 0.98; r3 = MinuteConversionLine * 0.96;
	for (var ind = 6; ind < 12; ind += 0.5) mark (ind, r1, r2);
	for (var ind = 12; ind < 30; ind ++) mark (ind, r1, r2);
	for (var ind = 30; ind < 60; ind += 6) {
		mark (ind, r1, r2); mark (ind + 1, r1, r2); mark (ind + 2, r1, r2);
		mark (ind + 3, r1, r3); mark (ind + 4, r1, r2); mark (ind + 5, r1, r2);
	}
	mark (6, r1, r3);
	ctx . stroke ();
	ctx . restore ();
	//==== CYFERBLAT MARKINGS ======================
	ctx . save ();
	r1 = Converters * -0.98; r2 = Converters * -0.95; r3 = Converters * -0.92; r4 = Converters * -0.88;
	ctx . beginPath ();
	for (var ind = 0; ind < 12; ind ++) {
		for (var sub = 0; sub < 0.98; sub += 0.2) {
			if (sub > 0) {var tick = ind + sub; if (tick >= 0.35 && tick <= 11.65) lmark ((ind + sub) / 12, r1, r3);}
			for (var esc = 0.05; esc < 0.2; esc += 0.05) {var tick = ind + sub + esc; if (tick >= 0.35 && tick <= 11.65) lmark (tick / 12, r1, r2);}
		}
	}
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1; ind < 24; ind += 2) lmark (ind / 24, r2 - 1, r4);
	ctx . strokeStyle = 'lime'; ctx . lineWidth = size * 0.01; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 2; ind < 24; ind += 2) lmark (ind / 24, r1, r2);
	ctx . lineWidth = size * 0.004; ctx . stroke ();
	ctx . restore ();
	//==== BREITLING LOGO ======================
	ctx . save ();
	var LogoScaling = size / 1200;
	ctx . scale (LogoScaling, LogoScaling);
	ctx . translate (BreitlingLogo . width * -0.5, size * -0.15 / LogoScaling);
	ctx . drawImage (BreitlingLogo, 0, 0);
	ctx . restore ();
	//==== WATCH MODEL ======================
	ctx . save ();
	ctx . fillStyle = 'white'; ctx . font = `${NumberSize2}px arial`; ctx . fillText ('COSMONAUTE', 0, size * -0.06); ctx . fillText ('1962', 0, size * -0.035);
	ctx . fillText ('NAVITIMER', 0, size * 0.06);
	ctx . restore ();
	//==== HOUR NUMBERS ======================
	ctx . save ();
	ctx . font = `bold ${HoursSize}px arial`; ctx . textBaseline = 'middle'; ctx . textAlign = 'center'; ctx . fillStyle = 'lime';
	for (var ind = 2; ind <= 24; ind += 2) {
		ctx . fillText (ind, HoursRadius * Math . sin (Math . PI * ind / 12), HoursRadius * - Math . cos (Math . PI * ind / 12));
	};
	ctx . restore ();
	//==== STATOR RED ARROWS ======================
	var t1 = - StatorTop + 1; t2 = StatorTop * -0.94; t3 = StatorTop * -0.89;
	ctx . save ();
	ctx . rotate (- pi2 * shift);
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill ();
	ctx . rotate (pi2 * Math . log10 (3.6));
	ctx . beginPath ();
	ctx . moveTo (0, t2); ctx . lineTo (s6, t3); ctx . lineTo (- s6, t3); ctx . closePath ();
	ctx . fill ();
	ctx . rotate (pi2 * (Math . log10 (3.3) - Math . log10 (3.6)));
	ctx . beginPath ();
	ctx . moveTo (0, t2); ctx . lineTo (s6, t3); ctx . lineTo (- s6, t3); ctx . closePath ();
	ctx . fill ();
	//ctx . rotate (pi2 * Math . log10 (1.15078));
	ctx . rotate (pi2 * (Math . log10 (3.8) - Math . log10 (3.3)));
	ctx . beginPath ();
	ctx . moveTo (0, t2); ctx . lineTo (s6, t3); ctx . lineTo (- s6, t3); ctx . closePath ();
	ctx . fill ();
	//ctx . rotate (pi2 * (Math . log10 (1.852) - Math . log10 (1.15078)));
	ctx . rotate (pi2 * (Math . log10 (6.1) - Math . log10 (3.8)));
	ctx . beginPath ();
	ctx . moveTo (0, t1); ctx . lineTo (s6, t2); ctx . lineTo (- s6, t2); ctx . closePath ();
	ctx . fill ();
	ctx . restore ();
	//==== MINUTE TOTALIZER ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (TotalizerRadius, 0);
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . strokeStyle = 'red'; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 0; ind < 30; ind += 5)
		for (var sub = 1; sub < 5; sub ++)
			lmark ((ind + sub) / 30, r1, r2);
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 6; ind ++) lmark (ind / 6, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbers * size; r2 = r1 * Math . cos (Math . PI * 2 / 3); r3 = r1 * Math . sin (Math . PI * 2 / 3);
	ctx . fillStyle = 'black'; ctx . textBaseline = 'middle';
	ctx . fillText (30, 0, - r1);
	ctx . fillText (10, r3, - r2);
	ctx . fillText (20, -r3, - r2);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 1800000) / 900000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 1800000) / 900000)));
	}
	ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
	ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
	ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill (); ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, ar4, r1, Math . PI - r1);
	ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
	ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = 'navy'; ctx . fill ();
	ctx . restore ();
	//==== HOUR TOTALIZER ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (0, TotalizerRadius);
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . strokeStyle = 'red'; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1; ind < 24; ind += 2) lmark (ind / 24, r1, r2);
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 12; ind ++) lmark (ind / 12, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbersH * size;
	ctx . fillStyle = 'black'; ctx . textBaseline = 'middle';
	ctx . fillText (12, 0, - r1);
	ctx . fillText (3, r1, 0);
	ctx . fillText (6, 0, r1);
	ctx . fillText (9, - r1, 0);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 43200000) / 21600000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 43200000) / 21600000)));
	}
	ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
	ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
	ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill (); ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, ar4, r1, Math . PI - r1);
	ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
	ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = 'navy'; ctx . fill ();
	ctx . restore ();
	//==== SECONDS HAND ================
	var TotalizerRadius = maker . TotalizerRadius * size;
	var TotalizerBezel = maker . TotalizerBezel * size;
	var TotalizerStator = maker . TotalizerStator * size;
	var r1 = maker . TotalizerR1 * size; var r2 = maker . TotalizerR2 * size; var r3 = maker . TotalizerR3 * size;
	ctx . save ();
	ctx . translate (- TotalizerRadius, 0);
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerBezel, 0, pi2);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . strokeStyle = 'red'; ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, TotalizerStator, 0, pi2);
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 0; ind < 12; ind += 4)
		for (var sub = 1; sub < 4; sub ++)
			lmark ((ind + sub) / 12, r1, r2);
	ctx . stroke ();
	var lw = ctx . lineWidth; ctx . beginPath (); for (var ind = 0; ind < 3; ind ++) lmark (ind / 3, r1, r3); ctx . lineWidth = 2; ctx . stroke ();
	ctx . beginPath ();
	r1 = maker . TotalizerNumbers * size; r2 = r1 * Math . cos (Math . PI * 2 / 3); r3 = r1 * Math . sin (Math . PI * 2 / 3);
	ctx . fillStyle = 'black'; ctx . textBaseline = 'middle';
	ctx . fillText (60, 0, - r1);
	ctx . fillText (20, r3, - r2);
	ctx . fillText (40, -r3, - r2);
	var ar1 = maker . TotalizerArrow1 * size;
	var ar2 = maker . TotalizerArrow2 * size;
	var ar3 = maker . TotalizerArrow3 * size;
	var ar4 = maker . TotalizerArrow4 * size;
	var ar5 = maker . TotalizerArrow5 * size;
	var ar6 = maker . TotalizerArrow6 * size;
	var ar7 = maker . TotalizerArrow7 * size;
	r1 = Math . asin (ar2 / ar4);
	ctx . rotate ((date . getSeconds () + date . getMilliseconds () / 1000) * Math . PI / 30 - Math . PI * 0.5);
	ctx . beginPath (); ctx . arc (0, 0, ar4, r1, pi2 - r1);
	ctx . lineTo (ar5, - ar3); ctx . lineTo (ar7, - ar3); ctx . lineTo (TotalizerStator, 0);
	ctx . lineTo (ar7, ar3); ctx . lineTo (ar5, ar3); ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill (); ctx . stroke ();
	ctx . beginPath ();
	ctx . arc (0, 0, ar4, r1, Math . PI - r1);
	ctx . lineTo (- ar6, ar2); ctx . lineTo (- ar6, - ar2);
	ctx . arc (0, 0, ar4, Math . PI + r1, pi2 - r1);
	ctx . fillStyle = 'white'; ctx . fill (); ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, ar1, 0, pi2); ctx . fillStyle = 'navy'; ctx . fill ();
	ctx . restore ();
	//==== DATE DISPLAY =======================
	ctx . save ();
	ctx . rotate (0.125 * pi2);
	ctx . beginPath ();
	var rct = {x: HoursRadius, y: 0, w1: HoursSize * 0.6, h1: HoursSize * 0.5, w2: HoursSize * 0.7, h2: HoursSize * 0.6};
	ctx . moveTo (rct . x - rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w2, rct . h2); ctx . lineTo (rct . x - rct . w2, rct . h2);
	ctx . lineTo (rct . x - rct . w2, - rct . h2); ctx . fillStyle = 'black'; ctx . fill ();
	ctx . lineTo (rct . x - rct . w1, - rct . h1);
	ctx . moveTo (rct . x + rct . w2, - rct . h2); ctx . lineTo (rct . x + rct . w1, - rct . h1);
	ctx . moveTo (rct . x + rct . w2, rct . h2); ctx . lineTo (rct . x + rct . w1, rct . h1);
	ctx . moveTo (rct . x - rct . w2, rct . h2); ctx . lineTo (rct . x - rct . w1, rct . h1);
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath (); ctx . moveTo (rct . x - rct . w1, - rct . h1);
	ctx . lineTo (rct . x + rct . w1, - rct . h1); ctx . lineTo (rct . x + rct . w1, rct . h1); ctx . lineTo (rct . x - rct . w1, rct . h1); ctx . closePath ();
	ctx . fillStyle = 'navy'; ctx . fill (); ctx . stroke ();
	ctx . font = `${HoursSize}px serif`;
	ctx . fillStyle = 'white'; ctx . textBaseline = 'middle'; ctx . textAlign = 'center'; ctx . fillText (Day, rct . x, rct . y);
	ctx . restore ();
	//==== HOUR HAND ======================
	ctx . save ();
	var ss6 = size * 0.006;
	ctx . rotate ((date . getHours () + date . getMinutes () / 60 + date . getSeconds () / 3600) * Math . PI / 12 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.02, 0.25, Math . PI * 2 - 0.25);
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (size * 0.15, size * -0.01);
	ctx . lineTo (size * 0.17, 0);
	ctx . lineTo (size * 0.15, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = 'silver';
	ctx . fill ();
	ctx . strokeStyle = 'black';
	ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = 'lime';
	ctx . moveTo (size * 0.04, - ss6);
	ctx . lineTo (size * 0.14, - ss6);
	ctx . lineTo (size * 0.15, 0);
	ctx . lineTo (size * 0.14, ss6);
	ctx . lineTo (size * 0.04, ss6);
	ctx . fill ();
	ctx . restore ();
	//==== MINUTE HAND ======================
	ctx . save ();
	ctx . rotate ((date . getMinutes () + date . getSeconds () / 60 + date . getMilliseconds () / 60000) * Math . PI / 30 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.016, 0.25, Math . PI * 2 - 0.25);
	r1 = Converters * -0.84; r2 = Converters * -0.91;
	r3 = Converters * -0.81; r4 = Converters * -0.83;
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (r1, size * -0.01);
	ctx . lineTo (r2, 0);
	ctx . lineTo (r1, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = 'lime';
	ctx . moveTo (size * 0.04, - ss6);
	ctx . lineTo (r3, - ss6);
	ctx . lineTo (r4, 0);
	ctx . lineTo (r3, ss6);
	ctx . lineTo (size * 0.04, ss6);
	ctx . fill ();
	ctx . restore ();
	//==== CHRONOGRAPH SECONDS TOTALIZER ================
	ctx . save ();
	var ss4 = size * 0.004;
	if (Chronograph . From === null) ctx . rotate (Math . PI * -0.5);
	else {
		if (Chronograph . To === null) ctx . rotate (Math . PI * (-0.5 + (((DateNumber - Chronograph . From) % 60000) / 30000)));
		else ctx . rotate (Math . PI * (-0.5 + (((Chronograph . To - Chronograph . From) % 60000) / 30000)));
	}
	r1 = Converters * -0.76; r2 = Converters * -0.78; r3 = Converters * -0.93; r4 = size * 0.02;
	ctx . beginPath ();
	ctx . moveTo (0, - ss4); ctx . lineTo (r2, - ss4); ctx . lineTo (r1, - r4);
	ctx . bezierCurveTo (Converters * -0.8, size * -0.012, Converters * -0.89, 0, r3, 0);
	ctx . bezierCurveTo (Converters * -0.89, 0, Converters * -0.8, size * 0.012, r1, r4);
	ctx . lineTo (r2, ss4);
	ctx . lineTo (0, ss4);
	ctx . closePath ();
	ctx . fillStyle = 'red'; ctx . fill (); ctx . strokeStyle = 'red'; ctx . stroke ();
	ctx . beginPath ();
	r1 = size * 0.012;
	r2 = Math . asin (ss4 / r1);
	ctx . arc (0, 0, r1, r2, Math . PI * 2 - r2);
	ctx . fillStyle = 'silver'; ctx . fill (); ctx . strokeStyle = 'black'; ctx . stroke ();
	ctx . restore ();
	//==== CURSOR ======================
	if (CursorVisible) {
		ctx . save ();
		ctx . strokeStyle = 'red';
		ctx . beginPath (); lmark (Cursor, - BezelRadius, HoursRadius); ctx . strokeStyle = 'red'; ctx . stroke ();
		var BezelText = Math . pow (10, Cursor - degree + Math . log10 (0.6));
		while (BezelText >= 100) BezelText /= 10; while (BezelText < 10) BezelText *= 10;
		var sin = Math . sin (Cursor * pi2); var cos = Math . cos (Cursor * pi2);
		var centre = {x: - BezelRadius * sin, y: BezelRadius * cos, width: NumberSize1 * 2, height: NumberSize1 * 0.7};
		ctx . beginPath ();
		ctx . moveTo (centre . x - centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y + centre . height);
		ctx . lineTo (centre . x - centre . width, centre . y + centre . height); ctx . closePath ();
		centre . x = HoursRadius * sin; centre . y = - HoursRadius * cos; centre . height = NumberSize1 * 1.25;
		ctx . moveTo (centre . x - centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y - centre . height);
		ctx . lineTo (centre . x + centre . width, centre . y + centre . height);
		ctx . lineTo (centre . x - centre . width, centre . y + centre . height); ctx . closePath ();
		ctx . fillStyle = 'black'; ctx . fill ();
		ctx . strokeStyle = 'red'; ctx . stroke ();
		ctx . font = `bold ${NumberSize1}px georgia`;
		ctx . fillStyle = 'red'; ctx . textBaseline = 'middle'; ctx . fillText (BezelText . toFixed (2), - BezelRadius * sin, BezelRadius * cos);
		var StatorText = Math . pow (10, Cursor + Math . log10 (0.6));
		while (StatorText >= 100) StatorText /= 10; while (StatorText < 10) StatorText *= 10;
		var ConverterText = StatorText; if (ConverterText < 60) ConverterText *= 10;
		ConverterText /= 60;
		ConverterText = `( ${Math . floor (ConverterText)}:${Math . round ((ConverterText % 1) * 60)} )`;
		ctx . textBaseline = 'bottom'; ctx . fillText (StatorText . toFixed (2), HoursRadius * sin, - HoursRadius * cos);
		ctx . textBaseline = 'top'; ctx . fillText (ConverterText, HoursRadius * sin, - HoursRadius * cos);
		ctx . restore ();
	}
	//======================
	ctx . restore ();
};

Interval = setInterval (repaint, 250);

</script>


</body>

</html>
