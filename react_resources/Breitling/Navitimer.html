<meta charset="UTF-8"/>

<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2021 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>


<header>
</header>

<body style="margin: 0px;">
<canvas id="Navitimer" width="1200" height="600"
	onmousedown="javascript: MouseDown (event);" onmouseup="javascript: MouseUp (event);"
	onmousemove="javascript: MouseMove (event);" onmouseleave="javascript: MouseUp (event);"
/>

<script type="text/javascript">

var Makers = {
	Breitling: {
		BezelRadius: 0.48,
		BezelRim: 0.44,
		BezelNumbers: 0.4,
		StatorTop: 0.37,
		StatorBottom: 0.32,
		//MinuteConversionLine: 0.295,
		MinuteConversionLine: 0.31,
		//Converters: 0.265,
		Converters: 0.28,
		NumberSize1: 0.036,
		NumberSize2: 0.026,
		HoursSize: 0.06,
		HoursRadius: 0.21
	}
};

var Maker = 'Breitling';

var BreitlingLogo = new Image (); BreitlingLogo . src = 'BreitlingWhiteScaled.png';

var canvas = document . getElementById ('Navitimer');
var ctx = canvas . getContext ('2d');
var pi2 = Math . PI + Math . PI;

var degree = 0;

var point = null;
var atan = null;

var MousePoint = function (e) {
	var rect = canvas . getBoundingClientRect ();
	return {x: e . clientX - rect . left - canvas . width / 2, y: e . clientY - rect . top - canvas . height / 2};
};

var MouseDown = function (e) {
	point = MousePoint (e);
	atan = Math . atan2 (point . y, point . x);
};

var MouseUp = function (e) {
	point = null;
};

var MouseMove = function (e) {
	if (! point) return;
	var p = MousePoint (e);
	var a = Math . atan2 (p . y, p . x);
	degree += a - atan; point = p; atan = a;
	repaint ();
};

var mark = function (position, r1, r2) {
	var angle = Math . log10 (position) * pi2;
	var sin = Math . sin (angle); var cos = - Math . cos (angle);
	ctx . moveTo (r1 * sin, r1 * cos); ctx . lineTo (r2 * sin, r2 * cos);
};

var repaint = function () {
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	var size = canvas . height;
	var BezelRadius = - Makers [Maker] . BezelRadius * size;
	var BezelDent = BezelRadius / -20;
	var BezelRim = Makers [Maker] . BezelRim * size;
	var StatorTop = Makers [Maker] . StatorTop * size;
	var StatorBottom = - Makers [Maker] . StatorBottom * size;
	var r1 = StatorTop + 1; var r2 = StatorTop * 1.04; var r3 = StatorTop * 1.05; var r4 = StatorTop * 1.06;
	var rm1 = StatorTop; var rm2 = StatorTop * 0.96; var rm3 = StatorTop * 0.95; var rm4 = StatorTop * 0.94;
	var MinuteConversionLine = Makers [Maker] . MinuteConversionLine * size;
	var Converters = - Makers [Maker] . Converters * size;
	var NumberSize1 = Makers [Maker] . NumberSize1 * size;
	var NumberSize2 = Makers [Maker] . NumberSize2 * size;
	var BezelNumber = - Makers [Maker] . BezelNumbers * size;
	var BezelLeft = Math . PI / 2 - 1;
	var BezelRight = Math . PI / 2 + 1;
	var HoursSize = Makers [Maker] . HoursSize * size;
	var HoursRadius = Makers [Maker] . HoursRadius * size;
	ctx . save ();
	ctx . textBaseline = 'alphabetic';
	ctx . textAlign = 'center';
	ctx . font = `${NumberSize1}px arial`;
	ctx . translate (canvas . width * 0.5, canvas . height * 0.5);
	//======================
	//======================
	ctx . save ();
	ctx . rotate (degree);
	ctx . beginPath ();
	for (var ind = 0; ind < 60; ind ++) {
		ctx . arc (0, BezelRadius, BezelDent, BezelRight, BezelLeft, true);
		ctx . rotate (Math . PI / 30);
	}
	ctx . closePath ();
	ctx . moveTo (StatorTop, 0);
	ctx . arc (0, 0, StatorTop, 0, Math . PI * 2, true);
	ctx . stroke (); ctx . fillStyle = 'black'; ctx . fill ();
	ctx . strokeStyle = 'red';
	ctx . beginPath (); ctx . arc (0, 0, BezelRim, 0, Math . PI * 2); ctx . stroke ();
	ctx . beginPath (); ctx . arc (0, 0, BezelRim + 2, 0, Math . PI * 2); ctx . stroke ();
	//ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . stroke ();
	ctx . restore ();
	//======================
	ctx . save();
	var shift = Math . log10 (6);
	var position = shift;
	ctx . rotate (- pi2 * position + degree);
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, r1, r3);
		mark (ind + 0.04, r1, r3);
		mark (ind + 0.06, r1, r3);
		mark (ind + 0.08, r1, r3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, r1, r2);
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.15, r1, r2);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.25, r1, r2);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.35, r1, r2);
		mark (ind + 0.4, r1, r3);
		mark (ind + 0.45, r1, r2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		mark (ind + 0.1, r1, r3);
		mark (ind + 0.2, r1, r3);
		mark (ind + 0.3, r1, r3);
		mark (ind + 0.4, r1, r3);
	}
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, r1, r4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, r1, r4);
	for (var ind = 6.5; ind < 12; ind += 0.5) mark (ind, r1, r4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . fillStyle = 'red'; ctx . fillText ('10', 0, BezelNumber); ctx . fillStyle = 'white';
	var next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, BezelNumber); position = next;
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, BezelNumber); position = next;
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, BezelNumber); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, BezelNumber); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, BezelNumber); position = next;
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, BezelNumber); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, BezelNumber); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, BezelNumber); position = next;
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, BezelNumber); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, BezelNumber); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, BezelNumber); position = next;
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, BezelNumber); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, BezelNumber); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, BezelNumber); position = next;
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, BezelNumber); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, BezelNumber); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, BezelNumber); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, BezelNumber); position = next;
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, BezelNumber); position = next;
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, BezelNumber); position = next;
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, BezelNumber); position = next;
	next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('60', 0, BezelNumber); position = next;
	next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('65', 0, BezelNumber); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('70', 0, BezelNumber); position = next;
	next = Math . log10 (7.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('75', 0, BezelNumber); position = next;
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('80', 0, BezelNumber); position = next;
	next = Math . log10 (8.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('85', 0, BezelNumber); position = next;
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('90', 0, BezelNumber); position = next;
	next = Math . log10 (9.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('95', 0, BezelNumber); position = next;
	ctx . restore ();
	//======================
	ctx . save ();
	ctx . beginPath (); ctx . arc (0, 0, StatorTop, 0, Math . PI * 2); ctx . fillStyle = 'navy'; ctx . fill ();
	ctx . rotate (- pi2 * shift);
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.5; ind += 0.1) {
		mark (ind + 0.02, rm1, rm3);
		mark (ind + 0.04, rm1, rm3);
		mark (ind + 0.06, rm1, rm3);
		mark (ind + 0.08, rm1, rm3);
	}
	for (var ind = 2.5; ind < 6; ind += 0.5) {
		mark (ind + 0.05, rm1, rm2);
		mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.15, rm1, rm2);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.25, rm1, rm2);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.35, rm1, rm2);
		mark (ind + 0.4, rm1, rm3);
		mark (ind + 0.45, rm1, rm2);
	}
	for (var ind = 6; ind < 12; ind += 0.5) {
		mark (ind + 0.1, rm1, rm3);
		mark (ind + 0.2, rm1, rm3);
		mark (ind + 0.3, rm1, rm3);
		mark (ind + 0.4, rm1, rm3);
	}
	mark (6, rm1, rm3);
	ctx . strokeStyle = 'white'; ctx . stroke ();
	ctx . beginPath ();
	for (var ind = 1.2; ind < 2.6; ind += 0.1) mark (ind, rm1, rm4);
	for (var ind = 3; ind < 6; ind += 0.5) mark (ind, rm1, rm4);
	for (var ind = 6.5; ind < 12; ind += 0.5) mark (ind, rm1, rm4);
	// mark (1.05, r1, r4);
	ctx . lineWidth = 3; ctx . stroke ();
	ctx . font = `${NumberSize2}px arial`;
	ctx . fillStyle = 'red'; ctx . fillText ('10', 0, StatorBottom); ctx . fillStyle = 'white'; ctx . fillText ('1:40', 0, Converters);
	next = Math . log10 (1.1); ctx . rotate (pi2 * next); ctx . fillText ('11', 0, StatorBottom); ctx . fillText ('1:50', 0, Converters); position = next;
	next = Math . log10 (1.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('12', 0, StatorBottom); ctx . fillText ('2:00', 0, Converters); position = next;
	next = Math . log10 (1.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('13', 0, StatorBottom); position = next;
	next = Math . log10 (1.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('14', 0, StatorBottom); position = next;
	next = Math . log10 (1.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('15', 0, StatorBottom); ctx . fillText ('2:30', 0, Converters); position = next;
	next = Math . log10 (1.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('16', 0, StatorBottom); position = next;
	next = Math . log10 (1.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('17', 0, StatorBottom); position = next;
	next = Math . log10 (1.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('18', 0, StatorBottom); ctx . fillText ('3:00', 0, Converters); position = next;
	next = Math . log10 (1.9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('19', 0, StatorBottom); position = next;
	next = Math . log10 (2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('20', 0, StatorBottom); position = next;
	next = Math . log10 (2.1); ctx . rotate (pi2 * (next - position)); ctx . fillText ('21', 0, StatorBottom); ctx . fillText ('3:30', 0, Converters); position = next;
	next = Math . log10 (2.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('22', 0, StatorBottom); position = next;
	next = Math . log10 (2.3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('23', 0, StatorBottom); position = next;
	next = Math . log10 (2.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('24', 0, StatorBottom); ctx . fillText ('4:00', 0, Converters); position = next;
	next = Math . log10 (2.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('25', 0, StatorBottom); position = next;
	next = Math . log10 (2.7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('4:30', 0, Converters); position = next;
	next = Math . log10 (3); ctx . rotate (pi2 * (next - position)); ctx . fillText ('30', 0, StatorBottom); ctx . fillText ('5:00', 0, Converters); position = next;
	next = Math . log10 (3.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('35', 0, StatorBottom); position = next;
	next = Math . log10 (3.6); ctx . rotate (pi2 * (next - position)); ctx . fillText ('6:00', 0, Converters); position = next;
	next = Math . log10 (4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('40', 0, StatorBottom); position = next;
	next = Math . log10 (4.2); ctx . rotate (pi2 * (next - position)); ctx . fillText ('7:00', 0, Converters); position = next;
	next = Math . log10 (4.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('45', 0, StatorBottom); position = next;
	next = Math . log10 (4.8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('8:00', 0, Converters); position = next;
	next = Math . log10 (5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('50', 0, StatorBottom); position = next;
	next = Math . log10 (5.4); ctx . rotate (pi2 * (next - position)); ctx . fillText ('9:00', 0, Converters); position = next;
	next = Math . log10 (5.5); ctx . rotate (pi2 * (next - position)); ctx . fillText ('55', 0, StatorBottom); position = next;
	//next = Math . log10 (6); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'red'; ctx . fillText ('60', 0, StatorBottom); position = next;
	next = Math . log10 (6.5); ctx . rotate (pi2 * (next - position)); ctx . fillStyle = 'white'; ctx . fillText ('65', 0, StatorBottom); position = next;
	next = Math . log10 (7); ctx . rotate (pi2 * (next - position)); ctx . fillText ('7', 0, StatorBottom); ctx . fillText ('1:10', 0, Converters); position = next;
	next = Math . log10 (8); ctx . rotate (pi2 * (next - position)); ctx . fillText ('8', 0, StatorBottom); ctx . fillText ('1:20', 0, Converters); position = next;
	next = Math . log10 (9); ctx . rotate (pi2 * (next - position)); ctx . fillText ('9', 0, StatorBottom); ctx . fillText ('1:30', 0, Converters); position = next;
	ctx . restore ();
	//======================
	ctx . save ();
	ctx . fillStyle = 'white';
	ctx . beginPath ();
	ctx . moveTo (0, - StatorTop);
	r1 = size * 0.025; r2 = Converters * 0.86;
	ctx . bezierCurveTo (0, Converters * 0.5 - StatorTop * 0.5, r1 * 0.5, Converters, r1, Converters);
	ctx . lineTo (- r1, Converters);
	ctx . bezierCurveTo (r1 * -0.5, Converters, 0, Converters * 0.5 - StatorTop * 0.5, 0, - StatorTop);
	ctx . fill ();
	ctx . fillText ('MPH', 0, Converters * 0.88);
	ctx . beginPath ();
	r1 = size * 0.045;
	ctx . moveTo (- r1, Converters);
	ctx . lineTo (- r1, r2); ctx . lineTo (r1, r2); ctx . lineTo (r1, Converters);
	ctx . strokeStyle = 'white'; ctx . lineWidth = 3; ctx . stroke ();
	ctx . rotate (pi2 * - shift);
	ctx . strokeStyle = 'white';
	ctx . beginPath (); ctx . arc (0, 0, MinuteConversionLine, 0, pi2); ctx . stroke ();
	ctx . beginPath ();
	r1 = MinuteConversionLine; r2 = MinuteConversionLine * 0.98; r3 = MinuteConversionLine * 0.96;
	for (var ind = 6; ind < 12; ind += 0.5) mark (ind, r1, r2);
	for (var ind = 12; ind < 30; ind ++) mark (ind, r1, r2);
	for (var ind = 30; ind < 60; ind += 6) {
		mark (ind, r1, r2); mark (ind + 1, r1, r2); mark (ind + 2, r1, r2);
		mark (ind + 3, r1, r3); mark (ind + 4, r1, r2); mark (ind + 5, r1, r2);
	}
	mark (6, r1, r3);
	ctx . stroke ();
	ctx . restore ();
	//======================
	ctx . save ();
	// ctx . rotate (degree * Math . PI / 48);
	// ctx . rotate (degree);
	ctx . scale (0.5, 0.5);
	ctx . translate (BreitlingLogo . width * -0.5, BreitlingLogo . height * -0.5);
	ctx . drawImage (BreitlingLogo, 0, size * -0.3);
	ctx . restore ();
	//======================
	ctx . save ();
	ctx . font = `${HoursSize}px arial`; ctx . textBaseline = 'middle'; ctx . textAlign = 'center'; ctx . fillStyle = 'lime';
	for (var ind = 2; ind <= 24; ind += 2) {
		ctx . fillText (ind, HoursRadius * Math . sin (Math . PI * ind / 12), HoursRadius * - Math . cos (Math . PI * ind / 12));
	};
	ctx . restore ();
	//======================
	var date = new Date (Date . now ());
	//======================
	ctx . save ();
	ctx . rotate ((date . getHours () + date . getMinutes () / 60) * Math . PI / 12 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.02, 0.25, Math . PI * 2 - 0.25);
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (size * 0.15, size * -0.01);
	ctx . lineTo (size * 0.17, 0);
	ctx . lineTo (size * 0.15, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = 'silver';
	ctx . fill ();
	ctx . strokeStyle = 'black';
	ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = 'lime';
	ctx . moveTo (size * 0.04, size * -0.004);
	ctx . lineTo (size * 0.14, size * -0.004);
	ctx . lineTo (size * 0.15, 0);
	ctx . lineTo (size * 0.14, size * 0.004);
	ctx . lineTo (size * 0.04, size * 0.004);
	ctx . fill ();
	ctx . restore ();
	//======================
	ctx . save ();
	ctx . rotate ((date . getMinutes () + date . getSeconds () / 60) * Math . PI / 30 - Math . PI * 0.5);
	ctx . beginPath ();
	ctx . arc (0, 0, size * 0.016, 0.25, Math . PI * 2 - 0.25);
	ctx . lineTo (size * 0.034, size * -0.01);
	ctx . lineTo (size * 0.26, size * -0.01);
	ctx . lineTo (size * 0.28, 0);
	ctx . lineTo (size * 0.26, size * 0.01);
	ctx . lineTo (size * 0.034, size * 0.01);
	ctx . closePath ();
	ctx . fillStyle = 'silver';
	ctx . fill ();
	ctx . strokeStyle = 'black';
	ctx . stroke ();
	ctx . beginPath ();
	ctx . fillStyle = 'lime';
	ctx . moveTo (size * 0.04, size * -0.004);
	ctx . lineTo (size * 0.25, size * -0.004);
	ctx . lineTo (size * 0.26, 0);
	ctx . lineTo (size * 0.25, size * 0.004);
	ctx . lineTo (size * 0.04, size * 0.004);
	ctx . fill ();
	ctx . restore ();
	//======================
	ctx . restore ();
	// degree += 1;
	if (degree > 96) degree = 0;
};

setInterval (repaint, 250);

</script>


</body>

</html>
